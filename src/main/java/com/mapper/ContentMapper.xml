<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper
        PUBLIC "-//mybatis.org//DTD Config 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="com.mapper.ContentMapper">
    <cache/>
    <resultMap id="contentMap" type="com.entity.ContentEntity">
        <id column="id" property="id"/>
        <result column="name" property="name"/>
        <result column="url" property="url"/>
        <result column="date" property="date"/>
        <result column="body" property="body"/>
        <result column="update_body" property="updateBody"/>
        <!--将关联查询的多条记录映射到collection，
        property对应着pojo的属性
        ofType指定集合属性中的pojo类型-->
        <collection property="contentDetailedsById" ofType="com.entity.ContentDetailedEntity">
            <id column="did" property="id"/>
            <result column="dname" property="name"/>
            <result column="content_id" property="contentId"/>
            <result column="dbody" property="body"/>
            <result column="dupdate_body" property="updateBody"/>
            <result column="ddate" property="date"/>

        </collection>

    </resultMap>
    <select id="findContent" resultMap="contentMap">
        SELECT
	content.id,
	content.`name`,
	content.url,
	content.date,
	content.body,
	content.update_body,
	content_detailed.id did,
	content_detailed.content_id,
	content_detailed.`name` dname,
	content_detailed.body dbody,
	content_detailed.update_body dupdatebody,
	content_detailed.date ddate
FROM
	content
INNER JOIN content_detailed ON content_detailed.content_id = content.id
    </select>

    <!--定义sql片段
    经验之谈，一般是基于单表来定义sql片段，这样的话，sql片段可重用性才高
    同时，sql片段不要包括where-->
    <sql id="query_where_content">
        <if test="contentExpand!=null">
            <if test="contentExpand.name!=null and contentExpand.name!=''">
                AND content.name LIKE '%${contentExpand.name}%'
            </if>
        </if>

    </sql>

    <select id="findContentByName" parameterType="ContentVo" resultType="ContentExpand">
        SELECT * FROM content
        <where>
            <!--引用sql片段-->
            <include refid="query_where_content"></include>
        </where>
    </select>


    <!--对用户信息进行延迟加载
    resultType不具备延迟加载-->
    <resultMap id="ContentLazyLoading" type="ContentDetailedEntity">
        <id column="id" property="id"/>
        <result column="content_id" property="contentId"/>
        <result column="name" property="name"/>
        <result column="body" property="body"/>
        <result column="date" property="date"/>
        <result column="update_body" property="updateBody"/>

        <!--select为延迟加载所加载的sql语句的id-->
        <association property="contentByContentId" javaType="ContentEntity"
                     select="findContentById" column="content_id">

        </association>
    </resultMap>
    
    <select id="findContentDetailedLazyLoading" resultMap="ContentLazyLoading">
        SELECT * FROM content_detailed
    </select>

    <select id="findContentById" parameterType="int" resultType="com.entity.ContentEntity">
        select * from shiyanloudb.content where id=#{id};
    </select>

</mapper>
